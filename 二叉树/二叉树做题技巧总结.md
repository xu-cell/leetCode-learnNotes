# 关键
- 二叉树的题可以说是遍历题，无论是求二叉树的属性，还是构造与修改二叉树，本质上都是对二叉树的遍历，对二叉树节点的访问。所以我们要熟悉二叉树的遍历方式的写法：前中后序的递归与遍历写法以及层序遍历的写法
## 规律
- 一般二叉树的构造都是采用中序遍历，无论是搜索二叉树还是普通二叉树，只有先构造出中间节点才能构造出左右节点。
- 求二叉树的属性一般采用的是后序遍历，在找路径的题中我们使用了前序。我们拿到题具体分析
- 在求二叉搜索树的性质的时候一般采用中序法，利用搜索树的性质，同时最好采用双指针法。
### 求二叉树性质
- **判断二叉树是否对称：** 如何判断一棵二叉树是否对称，根节点的左右子树如果相等，那么这棵树就相等，那左右子树怎样相等，它才是对称的？那么就是右子树的左节点与左子树的右节点，右子树的右节点与左子树的左节点相等。
-  **求最大深度与最小深度：** 最大深度，我觉得用层序遍历比较好理解，设置一个标记，循环到每一层就记录一下。最小深度有坑，要是节点无左右子节点才能算是最小深度。用层序遍历对于我来说也比交好理解。递归遍历也是比较好理解，如果一个节点的左节点为空，那么就返回1+另外一个节点的深度。还是采用后序遍历返回1+最小深度
- **求有多少个节点：** 用层序遍历，出栈一次记录一次
- **是否平衡？** 如何判断是否平衡，那么就是一个节点的左右子树的高度相差不大于一，那么就采用后序遍历求取每一个节点的高度。同时用-1记录，如果高度差大于一，就返回-1，如果正常就返回1+最大高度。在下次判断的时候就可以直接返回。不用再递归判断。
- **找所有路径：**  前序遍历，注意递归，不然无法找到所有的路径
- **求左叶子和：** 左叶子，我们只能判断一个节点的父节点判断左叶子。所以第一种办法是层序遍历所有节点，把每个节点的左叶子节点的和相加。递归法：后序遍历 求取每个节点的左叶子和并返回
- **求左下角值：** 层序遍历
- **求路径总和** ：设置一个计数器，遇到一个节点就减去这个节点的值，最后判断递归到了叶子节点的同时，检查计数器是否为0。
### 二叉树的修改与构造
- **翻转二叉树 ：** 前序遍历+swap 
- **构造二叉树** ：利用中序+前序 ，后序+中序。 在后序或者前序中找到根节点构造 ，在分割中序数组与前后序数组，继续递归。**构造最大二叉树**实际上是在一个数组里切割
- **合并二叉树** ：前序遍历。
### 求二叉搜索树的性质
- **判断是不是二叉搜索树** 两种方法，采用中序遍历将数放入数组中，遍历两两比较，第二：中序遍历+双指针比较 **求最小绝对差**同样中序遍历+双指针标记记录最小值）
- **求二叉搜索树的总数**： 两种方法：第一种：遍历将值放入哈希表中，在将哈希表中的值放入数组中排序，之后求取结果（针对普通的二叉树的做法，搜索树也适用）；第二种：双指针遍历，设置一个maxcount, 与count。
- **将二叉搜索树转化为一个累加树** ：反向中序 右中左叠加。
- ### 公共祖先问题
- **普通的二叉树：** 后序遍历：判断一个节点左右节点是不是p,q.是就返回对应节点。
- **搜索二叉树** 利用性质，只要确保值在p,q之间，那么这个值就是祖先
### 二叉搜索树的修改与构造
- **二叉搜索树的插入操作：** 利用性质找到最后的叶子节点处插入
- **删除操作 ：** 分情况：删除只有一个节点的节点，删除叶子节点，删除 有两个节点的节点
- **修建二叉搜索树**： 前序遍历，递归返回符号范围的值，如果一个节点的大于high返回他的左节点，小于low返回右节点
- **构造搜索二叉树** ：中序遍历，分割，每次取得数组中间的值作为头节点返回。
